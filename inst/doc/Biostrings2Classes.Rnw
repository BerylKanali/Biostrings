%\VignetteIndexEntry{Biostrings}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment} 
%\VignettePackage{Biostrings}

%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[11pt]{article}

%\usepackage{pstricks}
%\usepackage[authoryear,round]{natbib}
%\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\textwidth=6.2in

\bibliographystyle{plainnat} 
 
\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{The \Rpackage{Biostrings}~2 classes (work in progress)}
\author{Herv\'e Pag\`es}
\maketitle

\tableofcontents


% ---------------------------------------------------------------------------

\section{Introduction}

This document briefly presents a proposal for a new set of classes
designed to make manipulation of big strings (like DNA or RNA sequences)
easy and fast.
It keeps the 3 following ideas from the \Rpackage{Biostrings}~1
(\Rpackage{Biostrings} v~1.4.x) package:
(1) use R external pointers to store the string data,
(2) use bit patterns to encode them,
(3) let the user store a set of views {\it on the same} big string
    in a {\it single} object.

However, there is a flaw in the \Rclass{BioString} class design
that prevents the search algorithms to return correct information
about the matches (i.e. the views) that they found.
This proposal addresses this issue by replacing the \Rclass{BioString}
class by 2 new classes:
(1) the \Rclass{BString} class used to represent a {\it single} string, and
(2) the \Rclass{BStringViews} class used to represent a set of views
    {\it on the same} \Rclass{BString} object, and by introducing new
    implementations and new interfaces for these 2 classes.


% ---------------------------------------------------------------------------

\section{The \Rclass{BString} class and its subsetting operator~\Rmethod{[}}

A first \Rclass{BString} object:
<<a1>>=
library(Biostrings)
bs <- new("BString", "I am a BString object")
bs
length(bs)
@

The \Rclass{DNAString} and \Rclass{RNAString} classes are direct extensions
of the \Rclass{BString} class (no additional slot):
<<a2>>=
dna <- DNAString("TTGAAAA-CTC-N")
dna
length(dna)
@

Access to the individual letters:
<<a3>>=
dna[1]
dna[7:12]
dna[12:7]
bs[length(bs)]
bs[length(bs):(length(bs)-5)]
@

All the above values are character vectors of length 1.
To {\it dump} the whole \Robject{dna} as a character vector (of length 1):
<<a4>>=
dna[]
@
or
<<a5>>=
toString(dna)
@

Note that \Robject{length(dna)} is equivalent to \Robject{nchar(toString(dna))}
but the latter would be very inefficient on a big \Rclass{DNAString} object.


% ---------------------------------------------------------------------------

\section{The \Rmethod{==} binary operator for \Rclass{BString} objects}

<<b1>>=
new("BString", "ab") == "ab" # TRUE
"TG" == DNAString("TG") # TRUE
dna == DNAString("TG") # FALSE
@

Note that this produces an error because the empty string can't be converted
to a \Rclass{BString} object:
<<b2,echo=FALSE>>=
cat('> new("BString", "ab") == ""')
cat(try(new("BString", "ab") == ""))
@

You can't compare a \Rclass{DNAString} object with a \Rclass{BString}
object:
<<b3,echo=FALSE>>=
cat('DNAString("AA") == new("BString", "AA")')
cat(try(DNAString("AA") == new("BString", "AA")))
@

but you can compare it with a \Rclass{RNAString} object (and in this
case, a {\tt T} will be considered the same as an {\tt U}:
<<b4>>=
DNAString("TTTAG") == RNAString("UUUAG") # TRUE!!!
@


% ---------------------------------------------------------------------------

\section{The \Rclass{BStringViews} class and its subsetting
operators~\Rmethod{[} and~\Rmethod{[[}}

A \Rclass{BStringViews} object contains a set of views {\it on the same}
\Rclass{BString} (or \Rclass{DNAString}, or \Rclass{RNAString}) object,
the ``subject'' string.

Here is a \Rclass{BStringViews} object with a single view:
<<c1>>=
v1 <- BStringViews(dna, 2, 7)
v1
length(v1)
@

With 9 views:
<<c2>>=
v2 <- BStringViews(dna, 7:-1, 7:15)
v2
length(v2)
@

Note that the 2 last views are {\it out of limits}.

You can select a subset from a \Rclass{BStringViews} object:
<<c3>>=
v2[9:7]
@

The returned object is still a \Rclass{BStringViews} object,
even if we select only one element:
<<c4>>=
v2[3]
@

Use double-brackets to extract a given view as a \Rclass{BString} object:
<<c5>>=
v2[[3]]
@

You can't extract a view that is {\it out of limits}:
<<c6,echo=FALSE>>=
cat('> v2[[8]]')
cat(try(v2[[8]]))
@

The following is the same as doing \Robject{subject(v2)}
(provided as a convenience):
<<c7>>=
v2[[0]]
@

Subsetting also works with negative or logical values:
<<c8>>=
v2[-2:-8]
v2[c(TRUE, FALSE)]
@


% ---------------------------------------------------------------------------

\section{A few more \Rclass{BStringViews} objects}

12 views (all of the same width):
<<d1>>=
v <- BStringViews(DNAString("TAATAATG"), -2:9, 0:11)
@

This is the same as doing \Robject{BStringViews(dna, 1, length(dna))}:
<<d2>>=
BStringViews(dna)
@

Note that the following will always return the \Robject{dna} object itself:
<<d3,results=hide>>=
BStringViews(dna)[[1]]
@

3 \Rclass{BStringViews} objects with no view:
<<d4,results=hide>>=
v[0]
v[FALSE]
BStringViews(dna, integer(0), integer(0))
@


% ---------------------------------------------------------------------------

\section{The \Rmethod{==} binary operator for \Rclass{BStringViews} objects}

This one is vectorized:
<<e1>>=
v == v[4]
v == v[1]
v3 <- BStringViews(DNAString("G"), 1, 3)
v3
v == v3
@

Also works if one side is a \Rclass{BString} object:
<<e2>>=
v == DNAString("ATG")
RNAString("AUG") == v
@

Whitespace matters:
<<e3>>=
v == "TG"
@

But this doesn't work neither ({\tt "TG "} can't be converted to a
Rclass{DNAString} object):
<<e4,echo=FALSE>>=
cat('> v == "TG "')
@


% ---------------------------------------------------------------------------

\section{The \Rfunction{first}, \Rfunction{last} and \Rfunction{width}
functions}

<<f1>>=
first(v)
last(v)
width(v)
@

Note that \Robject{first(v)[i]} is equivalent to
\Robject{first(v[i])}, except that the former will not issue
an error if \Robject{i} is out of bounds
(same for \Rfunction{last} and \Rfunction{width} functions).

Also, when \Robject{i} is a {\it single} integer,
\Robject{width(v)[i]} is equivalent to \Robject{length(v[[i]])}
except that the former will not issue an error
if \Robject{i} is out of bounds or if view \Robject{v[i]}
is {\it out of limits}.


\end{document}
