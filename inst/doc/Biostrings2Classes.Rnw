%\VignetteIndexEntry{Biostrings}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment} 
%\VignettePackage{Biostrings}

%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[11pt]{article}

%\usepackage{pstricks}
%\usepackage[authoryear,round]{natbib}
%\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\textwidth=6.2in

\bibliographystyle{plainnat} 
 
\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{The \Rpackage{Biostrings}~2 classes (work in progress)}
\author{Herv\'e Pag\`es}
\maketitle

\tableofcontents


% ---------------------------------------------------------------------------

\section{Introduction}

This document briefly presents a proposal for a new set of classes
designed to make manipulation of big strings (like DNA or RNA sequences)
easy and fast.
It keeps the 3 following ideas from the \Rpackage{Biostrings}~1
(\Rpackage{Biostrings} v~1.4.x) package:
(1) use R external pointers to store the string data,
(2) use bit patterns to encode the string data,
(3) provide the user with a convenient class of container where he can store
    a set of views {\it on the same} big string (these views being typically
    the matches returned by a search algorithm).

However, there is a flaw in the \Rclass{BioString} class design
that prevents the search algorithms to return correct information
about the matches (i.e. the views) that they found.
This proposal addresses this issue by replacing the \Rclass{BioString}
class by 2 new classes:
(1) the \Rclass{BString} class used to represent a {\it single} string, and
(2) the \Rclass{BStringViews} class used to represent a set of views
    {\it on the same} \Rclass{BString} object, and by introducing new
    implementations and new interfaces for these 2 classes.


% ---------------------------------------------------------------------------

\section{The \Rclass{BString} class and its subsetting operator~\Rmethod{[}}

A first \Rclass{BString} object:
<<a1>>=
library(Biostrings)
b <- BString("I am a BString object")
b
length(b)
@

The \Rclass{DNAString} and \Rclass{RNAString} classes are direct extensions
of the \Rclass{BString} class (no additional slot):
<<a2>>=
d <- DNAString("TTGAAAA-CTC-N")
d
length(d)
@
The difference with a \Rclass{BString} object is that only letters from the
{\it IUPAC extended genetic alphabet} are allowed and that each letter in
the argument passed to the \Rfunction{DNAString} function is encoded in a
special way before it's stored in the \Rclass{DNAString} object.

Access to the individual letters:
<<a3>>=
d[3]
d[7:12]
d[]
b[length(b):1]
@
Only {\it in bounds} positive numeric subscripts are supported.

In fact the subsetting operator for \Rclass{BString} (or \Rclass{DNAString})
objects is not efficient and the \Rfunction{subBString} should be used instead
to extract a substring from a big object:
<<a4>>=
dd <- subBString(d, 3, 9)
@

To {\it dump} a \Rclass{BString} (or \Rclass{DNAString}) object as a character
vector (of length 1), use the \Rmethod{toString} method:
<<a5>>=
toString(dd)
@

Note that \Robject{length(dd)} is equivalent to \Robject{nchar(toString(dd))}
but the latter would be very inefficient on a big \Rclass{DNAString} object.

{\it [TODO: Make a generic of the substr() function to work with BString objects.
It will be essentially doing toString(subBString()).]}


% ---------------------------------------------------------------------------

\section{The \Rmethod{==} binary operator for \Rclass{BString} objects}

The 4 following expressions are \Robject{TRUE}:
<<b1,results=hide>>=
b == "ab"
d != DNAString("TG")
"TG" == DNAString("TG") 
DNAString("TG") == BString("TG")
@

When the 2 objects to compare don't belong to the same class then
the object belonging to the ``lowest'' class is first converted
to an object belonging to the ``highest'' class, where the class
(pseudo-)order is \Rclass{character} < \Rclass{BString} < \Rclass{DNAString}.

So in the case where both objects are \Rclass{BString} (or \Rclass{DNAString})
the comparison is very fast because it only has to call the C standard
function {\tt memcmp()}.

The 2 following expressions provoke an error because the right member can't
be ``upgraded'' (converted) to an object of the same class than the left member:
<<b2,echo=FALSE>>=
cat('> b == ""')
cat('> d == b')
@

You can also compare a \Rclass{DNAString} object with a \Rclass{RNAString} object:
<<b4>>=
DNAString("ACGT") == RNAString("UGCA") 
@


% ---------------------------------------------------------------------------

\section{The \Rclass{BStringViews} class and its subsetting
operators~\Rmethod{[} and~\Rmethod{[[}}

A \Rclass{BStringViews} object contains a set of views {\it on the same}
\Rclass{BString} (or \Rclass{DNAString}, or \Rclass{RNAString}) object,
the ``subject'' string.

Here is a \Rclass{BStringViews} object with a single view:
<<c1>>=
v1 <- BStringViews(d, 2, 7)
v1
length(v1)
@

With 9 views:
<<c2>>=
v2 <- BStringViews(d, 7:-1, 7:15)
v2
length(v2)
@

Note that the 2 last views are {\it out of limits}.

You can select a subset from a \Rclass{BStringViews} object:
<<c3>>=
v2[9:7]
@

The returned object is still a \Rclass{BStringViews} object,
even if we select only one element:
<<c4>>=
v2[3]
@

Use double-brackets to extract a given view as a \Rclass{BString} object:
<<c5>>=
v2[[3]]
@

You can't extract a view that is {\it out of limits}:
<<c6,echo=FALSE>>=
cat('> v2[[8]]')
cat(try(v2[[8]]))
@

The following is the same as doing \Robject{subject(v2)}
(provided as a convenience):
<<c7>>=
v2[[0]]
@

Subsetting also works with negative or logical values:
<<c8>>=
v2[-2:-8]
v2[c(TRUE, FALSE)]
@


% ---------------------------------------------------------------------------

\section{A few more \Rclass{BStringViews} objects}

12 views (all of the same width):
<<d1>>=
v <- BStringViews(DNAString("TAATAATG"), -2:9, 0:11)
@

This is the same as doing \Robject{BStringViews(d, 1, length(d))}:
<<d2>>=
BStringViews(d)
@

Note that the following will always return the \Robject{d} object itself:
<<d3,results=hide>>=
BStringViews(d)[[1]]
@

3 \Rclass{BStringViews} objects with no view:
<<d4,results=hide>>=
v[0]
v[FALSE]
BStringViews(d, integer(0), integer(0))
@


% ---------------------------------------------------------------------------

\section{The \Rmethod{==} binary operator for \Rclass{BStringViews} objects}

This one is vectorized:
<<e1>>=
v == v[4]
v == v[1]
v3 <- BStringViews(DNAString("G"), 1, 3)
v3
v == v3
@

Also works if one side is a \Rclass{BString} object:
<<e2>>=
v == DNAString("ATG")
RNAString("AUG") == v
@

Whitespace matters:
<<e3>>=
v == "TG"
@

But this doesn't work neither ({\tt "TG "} can't be converted to a
Rclass{DNAString} object):
<<e4,echo=FALSE>>=
cat('> v == "TG "')
@


% ---------------------------------------------------------------------------

\section{The \Rfunction{first}, \Rfunction{last} and \Rfunction{width}
functions}

<<f1>>=
first(v)
last(v)
width(v)
@

Note that \Robject{first(v)[i]} is equivalent to
\Robject{first(v[i])}, except that the former will not issue
an error if \Robject{i} is out of bounds
(same for \Rfunction{last} and \Rfunction{width} functions).

Also, when \Robject{i} is a {\it single} integer,
\Robject{width(v)[i]} is equivalent to \Robject{length(v[[i]])}
except that the former will not issue an error
if \Robject{i} is out of bounds or if view \Robject{v[i]}
is {\it out of limits}.


\end{document}
