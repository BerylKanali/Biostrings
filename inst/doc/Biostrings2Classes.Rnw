%\VignetteIndexEntry{Biostrings}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment} 
%\VignettePackage{Biostrings}

%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[11pt]{article}

%\usepackage{pstricks}
%\usepackage[authoryear,round]{natbib}
%\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\textwidth=6.2in

\bibliographystyle{plainnat} 
 
\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{The \Rpackage{Biostrings}~2 classes (work in progress)}
\author{Herv\'e Pag\`es}
\maketitle

\tableofcontents


% ---------------------------------------------------------------------------

\section{Introduction}

This document briefly presents a proposal for a new set of classes
designed to make manipulation of big strings (like DNA or RNA sequences)
easy and fast.
It keeps the 3 following ideas from the \Rpackage{Biostrings}~1
(\Rpackage{Biostrings} v~1.4.x) package:
(1) use R external pointers to store the string data,
(2) use bit patterns to encode the string data,
(3) provide the user with a convenient class of objects where each instance
    can store a set of views {\it on the same} big string (these views being
    typically the matches returned by a search algorithm).

However, there is a flaw in the \Rclass{BioString} class design
that prevents the search algorithms to return correct information
about the matches (i.e. the views) that they found.
This proposal addresses this issue by replacing the \Rclass{BioString}
class by 2 new classes:
(1) the \Rclass{BString} class used to represent a {\it single} string, and
(2) the \Rclass{BStringViews} class used to represent a set of views
    {\it on the same} \Rclass{BString} object, and by introducing new
    implementations and new interfaces for these 2 classes.


% ---------------------------------------------------------------------------

\section{The \Rclass{BString} class and its subsetting operator~\Rmethod{[}}

A first \Rclass{BString} object:
<<a1>>=
library(Biostrings)
b <- BString("I am a BString object")
b
length(b)
@

The \Rclass{DNAString} and \Rclass{RNAString} classes are direct extensions
of the \Rclass{BString} class (no additional slot):
<<a2>>=
d <- DNAString("TTGAAAA-CTC-N")
d
length(d)
@
The differences with a \Rclass{BString} object are: (1) only letters from the
{\it IUPAC extended genetic alphabet} + the gap letter ({\tt -}) are allowed
and (2) each letter in the argument passed to the \Rfunction{DNAString}
function is encoded in a special way before it's stored in the
\Rclass{DNAString} object.

Access to the individual letters:
<<a3>>=
d[3]
d[7:12]
d[]
b[length(b):1]
@
Only {\it in bounds} positive numeric subscripts are supported.

In fact the subsetting operator for \Rclass{BString} (or \Rclass{DNAString})
objects is not efficient and one should always use the \Rfunction{subBString}
function to extract a substring from a big object:
<<a4>>=
bb <- subBString(b, 3, 6)
dd1 <- subBString(d, last=7)
dd2 <- subBString(d, first=8)
@

To {\it dump} a \Rclass{BString} (or \Rclass{DNAString}) object as a character
vector (of length 1), use the \Rmethod{toString} method:
<<a5>>=
toString(dd2)
@

Note that \Robject{length(dd2)} is equivalent to
\Robject{nchar(toString(dd2))} but the latter would be very inefficient
on a big \Rclass{DNAString} object.

{\it [TODO: Make a generic of the substr() function to work with BString objects.
It will be essentially doing toString(subBString()).]}


% ---------------------------------------------------------------------------

\section{The \Rmethod{==} binary operator for \Rclass{BString} objects}

The 4 following expressions are \Robject{TRUE}:
<<b1,results=hide>>=
bb == "am a"
dd2 != DNAString("TG")
"-CTC-N" == dd2
DNAString("AC") == BString("AC")
@

When the 2 objects to compare don't belong to the same class then
the object belonging to the ``lowest'' class is first converted
to an object belonging to the ``highest'' class, where the class
(pseudo-)order is \Rclass{character} < \Rclass{BString} < \Rclass{DNAString}.
In the case where both objects are \Rclass{BString} (or \Rclass{DNAString})
the comparison is very fast because it only has to call the C standard
function {\tt memcmp()} and no memory allocation or string encoding
is required.

The 2 following expressions provoke an error because the right member can't
be ``upgraded'' (converted) to an object of the same class than the left member:
<<b2,echo=FALSE>>=
cat('> bb == ""')
cat('> d == bb')
@

A \Rclass{DNAString} object and a \Rclass{RNAString} object are considered
equals when they are complementary:
<<b3>>=
DNAString("ACGT") == RNAString("UGCA")
@
Note that this behaviour is consistent with the fact that
\Robject{RNAString(DNAString("ACGT"))} is equal
to \Robject{RNAString("UGCA")} and
\Robject{DNAString(RNAString("UGCA"))} is equal
to \Robject{DNAString("ACGT")}.


% ---------------------------------------------------------------------------

\section{The \Rclass{BStringViews} class and its subsetting
operators~\Rmethod{[} and~\Rmethod{[[}}

A \Rclass{BStringViews} object contains a set of views {\it on the same}
\Rclass{BString} (or \Rclass{DNAString}, or \Rclass{RNAString}) object
called the {\it subject} string.
Here is a \Rclass{BStringViews} object with 4 views:
<<c1>>=
v4 <- BStringViews(dd2, 3:0, 5:8)
v4
length(v4)
@

Note that the 2 last views are {\it out of limits}.

You can select a subset of views from a \Rclass{BStringViews} object:
<<c3>>=
v4[4:2]
@

The returned object is still a \Rclass{BStringViews} object,
even if we select only one element.
You need to use double-brackets to extract a given view
as a \Rclass{BString} object:
<<c4>>=
v4[[2]]
@

You can't extract a view that is {\it out of limits}:
<<c6,echo=FALSE>>=
cat('> v4[[3]]')
cat(try(v4[[3]]))
@

Note that, when \Robject{first} and \Robject{last} are numeric
vectors and \Robject{i} is a {\it single} integer,
\Robject{BStringViews(b, first, last)[[i]]}
is equivalent to \Robject{subBString(b, first[i], last[i])}.

The following is the same as doing \Robject{subject(v4)}
(provided as a convenience):
<<c7>>=
v4[[0]]
@

Subsetting also works with negative or logical values with the expected
semantic (the same as for R built-in vectors):
<<c8>>=
v4[-3]
v4[c(TRUE, FALSE)]
@
Note that the logical vector is recycled to the length of \Robject{v4}.


% ---------------------------------------------------------------------------

\section{A few more \Rclass{BStringViews} objects}

12 views (all of the same width):
<<d1>>=
v12 <- BStringViews(DNAString("TAATAATG"), -2:9, 0:11)
@

This is the same as doing \Robject{BStringViews(d, 1, length(d))}:
<<d2,results=hide>>=
BStringViews(d)
@

Hence the following will always return the \Robject{d} object itself:
<<d3,results=hide>>=
BStringViews(d)[[1]]
@

3 \Rclass{BStringViews} objects with no view:
<<d4,results=hide>>=
v12[0]
v12[FALSE]
BStringViews(d, integer(0), integer(0))
@


% ---------------------------------------------------------------------------

\section{The \Rmethod{==} binary operator for \Rclass{BStringViews} objects}

This operator is the vectorized version of the \Rmethod{==} operator
defined previously for \Rclass{BString} (or \Rclass{DNAString}) objects:
<<e1>>=
v12 == "TAA"
@

To display all the views in \Robject{v12} that are equals to a given view,
you can type R cuties like:
<<e2>>=
v12[v12 == v12[4]]
v12[v12 == v12[1]]
@

This is \Robject{FALSE} (whitespace matters):
<<e3,results=hide>>=
v12[3] == "TA"
@
and this provokes an error:
<<e4,echo=FALSE>>=
cat('> v12[3] == " TA"')
@
but these are \Robject{TRUE}:
<<e5,results=hide>>=
v12[3] == BStringViews(BString("TA"), 0, 2)
v12[3] == BStringViews(RNAString("AU"), 0, 2)
@


% ---------------------------------------------------------------------------

\section{The \Rfunction{first}, \Rfunction{last} and \Rfunction{width}
functions}

<<f1>>=
first(v4)
last(v4)
width(v4)
@

Note that \Robject{first(v4)[i]} is equivalent to
\Robject{first(v4[i])}, except that the former will not issue
an error if \Robject{i} is out of bounds
(same for \Rfunction{last} and \Rfunction{width} functions).

Also, when \Robject{i} is a {\it single} integer,
\Robject{width(v4)[i]} is equivalent to \Robject{length(v4[[i]])}
except that the former will not issue an error
if \Robject{i} is out of bounds or if view \Robject{v4[i]}
is {\it out of limits}.


\end{document}
