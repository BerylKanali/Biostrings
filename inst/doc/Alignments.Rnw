%\VignetteIndexEntry{Some examples of sequence alignments}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment} 
%\VignettePackage{Biostrings}

%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[12pt]{article}

\usepackage{amsmath,pstricks}
\usepackage[authoryear,round]{natbib}
\usepackage{hyperref}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\textwidth=6.2in

\bibliographystyle{plainnat} 
 
\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{Alignments}
\author{Patrick Aboyoun}
\maketitle

\tableofcontents

\section{Introduction}

In this document we illustrate how to perform pairwise alignments using the
Biostrings package.

\section{Data import}
\label{fastaread}

The \Rpackage{Biostrings} package includes FASTA files encoding the DNA sequence
for Yeast chromosome I, along with some ORFs. Here we load the {\tt someORF.fa}
file into a \Rclass{DNAStringSet} object by using the \Rfunction{read.DNAStringSet}
function:
<<gety>>=
library(Biostrings)
file <- system.file("extdata", "someORF.fa", package="Biostrings")
orf <- read.DNAStringSet(file, "fasta")
orf
@
Note that some of the ORF sequences are represented in reverse complement form.


\section{Optimal Pairwise Alignments}

The function \Rfunction{pairwiseAlignment} solves the (Needleman-Wunsch) global,
the (Smith-Waterman) local, and overlap optimal pairwise alignment problems.
These problems are described as follows. Let string $S_i$ have $n_i$ characters
$c_{(i,j)}$ with $j \in \left\{1, \ldots, n_i\right\}$. A pairwise alignment is
a mapping of strings $S_1$ and $S_2$ to "gapped" substrings ${S'}_1$ and ${S'}_2$
that are defined by

\begin{eqnarray*}
{S'}_1 & = & g_{\left(1,a_1\right)}c_{\left(1,a_1\right)} \cdots g_{\left(1,b_1\right)}c_{\left(1,b_1\right)}g_{\left(1,b_1+1\right)}\\
{S'}_2 & = & g_{\left(1,a_2\right)}c_{\left(1,a_2\right)} \cdots g_{\left(1,b_2\right)}c_{\left(1,b_2\right)}g_{\left(1,b_2+1\right)}
\end{eqnarray*}
\begin{tabbing}
  where \= \\
  \> $a_i, b_i \in \{1, \ldots, n_i\}$ with $a_i \leq b_i$ \\
  \> $g_{(i,j)} = 0$ or more gaps at the specified position $j$ for aligned string $i$ \\
  \> $length({S'}_1) = length({S'}_2)$
\end{tabbing}

The quality of a pairwise alignment is dependent on the distance, or
\textit{score}, between two gapped substrings. The score is determined by the
type of pairwise alignment, which sets the $[a_i, b_i]$ ranges for the
substrings; the substitution scoring scheme, which sets the distance between
aligned characters; and the gap penalties, which is divided into opening and
extension components. The optimal pairwise alignment is the pairwise alignment
with the largest score for the specified alignment type, substitution scoring
scheme, and gap penalties.

\begin{description}
  \item{Pairwise Alignment Type:  }
  The \Rfunarg{type} argument sets the ranges for the aligned substrings by
  accepting one of \texttt{"global"}, \texttt{"local"}, \texttt{"overlap"},
  \texttt{"subjectOverlap"}, and \texttt{"patternOverlap"}. The associated
  ranges for these pairwise alignment types are:
  \begin{description}
    \item{Global - } $[a_1, b_1] = [1, n_1]$ and $[a_2, b_2] = [1, n_2]$
    \item{Local - } $[a_1, b_1]$ and $[a_2, b_2]$
    \item{Overlap - }
      $\left\{[a_1, b_1] = [a_1, n_1], [a_2, b_2] = [1, b_2]\right\}$ or
      $\left\{[a_1, b_1] = [1, b_1], [a_2, b_2] = [a_2, n_2]\right\}$
    \item{Subject Overlap - } $[a_1, b_1] = [1, n_1]$ and $[a_2, b_2]$
    \item{Pattern Overlap - } $[a_1, b_1]$ and $[a_2, b_2] = [1, n_2]$
  \end{description}
  \item{Substitution Scores:  }
  The substitution scores can either be fixed for each pairing of letters
  within the two strings or be dependent on the qualities associated with those
  letters. When the scores are fixed by pairing, the \Rfunarg{substituionMatrix}
  argument takes a matrix with the appropriate alphabets as dimension names.
  When the scores are quality-based, the \Rfunarg{qualityType} sets the type
  of quality score to use (\texttt{"Phred"} or \texttt{"Solexa"}) and the
  \Rfunarg{patternQuality} and \Rfunarg{subjectQuality} arguments accept the
  equivalent of [0-99] numeric quality values for the respective strings. For
  \texttt{"Phred"} quality measures $Q \in [0, 99]$, the probability of an
  error in the base read is given by $10^{-Q/10}$ and for \texttt{"Solexa"}
  quality measures $Q \in [-5, 99]$, they are given by $1 - 1/(1 + 10^{-Q/10})$.
  \item{Gap Penalties:  }
  Gaps have the potential to incur a cost when they are introduced and when they
  are extended in an optimal pairwise alignment. The former is regulated by the
  \Rfunarg{gapOpening} argument and the latter by the \Rfunarg{gapExtension}
  argument. For whole string alignments, end/terminal gaps can be ignored by
  setting the \Rfunarg{type} argument to \texttt{"overlap"} (ignore end gaps in
  both strings), \texttt{"patternOverlap"} (ignore end gaps in \Rfunarg{pattern}),
  or \texttt{"subjectOverlap"} (ignore end gaps in \Rfunarg{subject}).
\end{description}

The \Rfunction{pairwiseAlignment} function uses memory and computation time
proportional to the product of the two string lengths.

The BLOSUM50 matrix is available in this package as a matrix:
<<lkblo>>=
data(BLOSUM50)
BLOSUM50[1:4,1:4]
@
A comparison of the three optimal pairwise alignments problems from Haubold and Wiehe:
<<haubold>>=
s1 <- 
  DNAString("ACTTCACCAGCTCCCTGGCGGTAAGTTGATCAAAGGAAACGCAAAGTTTTCAAG")
s2 <-
  DNAString("GTTTCACTACTTCCTTTCGGGTAAGTAAATATATAAATATATAAAAATATAATTTTCATC")

mat <- matrix(-3, nrow = 4, ncol = 4)
diag(mat) <- 1
rownames(mat) <- colnames(mat) <- DNA_ALPHABET[1:4]
globalAlign <- pairwiseAlignment(s1, s2, substitutionMatrix = mat,
  gapOpening = -5, gapExtension = -2)
localAlign <- pairwiseAlignment(s1, s2, type = "local", substitutionMatrix = mat,
  gapOpening = -5, gapExtension = -2)
overlapAlign <- pairwiseAlignment(s1, s2, type = "overlap",
  substitutionMatrix = mat, gapOpening = -5, gapExtension = -2)
@
A canonical global optimal pairwise alignment example from Durbin, Eddy et al:
<<runnw>>=
nwdemo <- 
  pairwiseAlignment(AAString("PAWHEAE"), AAString("HEAGAWGHEE"), substitutionMatrix = BLOSUM50,
                    gapOpening = 0, gapExtension = -8)
nwdemo
@
The score (final element of dynamic programming score matrix) can be accessed:
<<lksc>>=
score(nwdemo)
@


\section{Computing alignment consensus matrices}

The \Rfunction{consmat} function is provided for computing a consensus matrix
for a set of equal-length strings assumed to be aligned. To illustrate, the
following application assumes the ORF data to be aligned for the first 10
positions (patently false):
<<doal>>=
orf10 <- DNAStringSet(orf, end=10)
consmat(orf10)
@

The information content as defined by Hertz and Stormo 1995 is computed as
follows:
<<infco>>= 
infContent <- function(Lmers) {
 zlog <- function(x) ifelse(x==0,0,log(x))
 co <- consmat(Lmers, freq=TRUE)
 lets <- rownames(co)
 fr <- alphabetFrequency(Lmers)[lets]
 sum(co*zlog(co/fr))
}
infContent(orf10)
@


\end{document}
