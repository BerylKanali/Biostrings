%\VignetteIndexEntry{Multiple Alignments}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment}
%\VignettePackage{Biostrings}


\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\newcommand{\R}{{\textsf{R}}}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\term}[1]{{\emph{#1}}}
\newcommand{\Rpackage}[1]{\textsf{#1}}
\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}
\newcommand{\Rfunarg}[1]{{\textit{#1}}}

\bibliographystyle{plainnat}

\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{MultipleAlignment Objects}
\author{Marc Carlson\\
  Bioconductor Core Team \\
  Fred Hutchinson Cancer Research Center \\
  Seattle, WA}
\date{\today}
\maketitle

\tableofcontents

\section{Introduction}
The \Rclass{DNAMultipleAlignment} \Rclass{RNAMultipleAlignment} and
\Rclass{AAMultipleAlignment} classes was created to allow users to
represent groups of DNA, RNA or AA sequences that had been aligned as
a simple objects.  Because these objects are based on alignments where
the frame of reference for the sequences contained by them is static
relative to each other, manipulations of these objects are confined to
be non-destructive.  In practice, this means that these objects
contain slots to mask ranges of rows and columns on the original
sequence.  These masks are then respected by methods that display
these objects, thus allowing the user to remove or expose columns and
rows without damaging the original alignment.

\section{Creation and masking}
To create a \Rclass{MultipleAlignment} you simply need to call the
appropriate read function so that the original alignment can be read
in and parsed.  There are read functions for all three classes that
support both clustaW and Stolkholm data formats.


<<objectCreation>>=
library(Biostrings)
origMAlign <-
  read.DNAMultipleAlignment(filepath =
                            system.file("extdata",
                                        "msx2_mRNA.aln",
                                        package="Biostrings"),
                            format="clustal")
@

Rows can be renamed with \Rfunction{rownames}.

<<renameRows>>=
rownames(origMAlign)
rownames(origMAlign) <- c("Human","Chimp","Cow","Mouse","Rat",
                          "Dog","Chicken","Salmon")
origMAlign
@ 

And applying masks is a simple matter of specifying which ranges to hide.
<<usingMasks>>=
maskTest <- origMAlign
rowmask(maskTest) <- IRanges(start=1,end=3)
rowmask(maskTest)
maskTest

colmask(maskTest) <- IRanges(start=c(1,1000),end=c(500,2343))
colmask(maskTest)
maskTest
@ 

You can also remove row and column masks by assigning NULL like this:

<<nullOut masks>>=
rowmask(maskTest) <- NULL
rowmask(maskTest)
colmask(maskTest) <- NULL
colmask(maskTest)
maskTest
@ 

But there are also other options.  When setting a mask, you might want
to set it up as a selection instead of a masking.  That is, you might
want to specify which rows and columns you wish to keep instead of
which ones you want to throw away.  To do that, you would use the
\Rfunarg{invert} argument.  Taking the above example, we can set the
exact same masks as before by just specifying their inverse and
setting invert=TRUE.

<<invertMask>>=
rowmask(maskTest, invert=TRUE) <- IRanges(start=4,end=8)
rowmask(maskTest)
maskTest
colmask(maskTest, invert=TRUE) <- IRanges(start=501,end=999)
colmask(maskTest)
maskTest
@ 

In addition to being able to invert these masks, you can also choose
the way in which the ranges you provide will be merged with any
existing masks. The \Rfunarg{append} argument allows you to specify
the way in which new mask ranges will interact with any existing
masks.  By default, these masks will be the "union" of the new mask
and any existing masks, but you can also specify that these masks be
the mask that results from when you "intersect" the current mask and
the new mask, or that the new mask simply "replace" the current mask.
The \Rfunarg{append} argument can be used in combination with the
\Rfunarg{invert} argument to make things even more interesting.  In
this case, the inversion of the mask will happen before it is combined
with the existing mask.  For simplicity, I will only demonstrate this
on \Rmethod{rowmask}, but it also works for \Rmethod{colmask}.

<<appendMask>>=
rowmask(maskTest) <- IRanges(start=1,end=3)
maskTest

rowmask(maskTest,append="intersect") <- IRanges(start=2,end=5)
maskTest

rowmask(maskTest,append="replace") <- IRanges(start=5,end=8)
maskTest

rowmask(maskTest,append="replace",invert=TRUE) <- IRanges(start=5,end=8)
maskTest

rowmask(maskTest,append="union") <- IRanges(start=7,end=8)
maskTest
@ 


The function \Rfunction{maskMotif} works on \Rclass{MultipleAlignment}
objects too, and takes the same arguments that it does
elsewhere. \Rfunction{maskMotif} is useful for masking occurances of a
string from columns where it is present in the consensus sequence.

<<maskMotif>>= 
tataMasked <- maskMotif(origMAlign, "TATA")
colmask(tataMasked)
@ 

\Rfunction{maskGaps} also operates on columns and will mask collumns
based on the fraction of each column that contains gaps
\Rfunarg{min.fraction} along with the width of columns that contain
this fraction of gaps \Rfunarg{min.block.width}.


<<maskGaps>>=
autoMasked <- maskGaps(origMAlign, min.fraction=0.5, min.block.width=4)
autoMasked
@ 


\section{Analytic utilities}
Once you have masked the sequence, you can then ask questions about
the properties of that sequence.  For example, you can look at the
alphabet frequency of that sequence.  The alphabet frequency will only
be for the masked sequence.

<<alphabetFreq>>=
alphabetFrequency(autoMasked)
@ 

You can also calculate a consensus matrix, extract the consensus
string or look at the consensus views.  These methods too will all
consider the masking when you run them.  

<<consensus>>=
consensusMatrix(autoMasked, baseOnly=TRUE)[, 84:90]
substr(consensusString(autoMasked),80,130)
consensusViews(autoMasked)
@ 

You can also cluster the alignments based on their distance to each
other.  Because you must pass in a DNAStringSet, the clustering will
also take into account the masking. So for example, you can see how
clustering the unmasked \Robject{DNAMultipleAlignment} will draw a
funky looking tree.  

<<cluster>>=
sdist <- stringDist(as(origMAlign,"DNAStringSet"), method="hamming")
clust <- hclust(sdist, method = "single")
pdf(file="badTree.pdf")
plot(clust)
dev.off()
@ 

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{badTree}
\caption{\label{f1} Funky tree produced by using unmasked strings.}
\end{center}
\end{figure}

But, if we use the gap-masked \Robject{DNAMultipleAlignment}, to
remove the long uninformative regions, and then make our plot, we can
see the real relationships.

%% could also have just done <<cluster2, fig=TRUE>>=
<<cluster2>>=
sdist <- stringDist(as(autoMasked,"DNAStringSet"), method="hamming")
clust <- hclust(sdist, method = "single")
pdf(file="goodTree.pdf")
plot(clust)
dev.off()
fourgroups <- cutree(clust, 4)
fourgroups
@ 

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{goodTree}
\caption{\label{f2} A tree produced by using strings with masked gaps.}
\end{center}
\end{figure}

In the "good" plot, the Salmon sequence is once again the most distant
which is what we expect to see.  A closer examination of the sequence
reveals that the similarity between the mouse, rat and human sequences
was being inflated by virtue of the fact that those sequences were
simply much longer (had more information than) the other species
represented.  This is what caused the "funky" result. The relationship
between the sequences in the funky tree was being driven by extra
"length" in the rodent/mouse/human sequences, instead of by the
similarity of the conserved regions.


\section{Session Information}
All of the output in this vignette was produced under the following
conditions:

<<sessinfo>>=
sessionInfo()
@

\end{document}

